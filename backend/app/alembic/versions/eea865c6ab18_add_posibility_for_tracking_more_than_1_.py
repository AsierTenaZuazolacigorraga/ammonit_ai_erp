"""Add posibility for tracking more than 1 email

Revision ID: eea865c6ab18
Revises: 63bd0dee65f4
Create Date: 2025-05-09 17:14:10.318632

"""

import sqlalchemy as sa
import sqlmodel.sql.sqltypes
from alembic import op
from sqlalchemy import text
from sqlalchemy.dialects import postgresql
from sqlalchemy.schema import CreateTable

# revision identifiers, used by Alembic.
revision = "eea865c6ab18"
down_revision = "63bd0dee65f4"
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###

    # Check if the enum type already exists
    connection = op.get_bind()

    # For PostgreSQL, we need to check if the enum exists in the database
    enum_exists = False
    try:
        # Try to execute a query that will succeed only if the enum exists
        connection.execute(text("SELECT 'PROCESSED'::email_state_enum"))
        enum_exists = True
    except Exception:
        enum_exists = False

    if not enum_exists:
        # Create the enum type if it doesn't exist
        email_state_enum = postgresql.ENUM(
            "PROCESSED", "ERROR", name="email_state_enum", create_type=True
        )
        email_state_enum.create(connection)

    # Create the table without creating the enum again
    op.create_table(
        "emaildata",
        sa.Column("email_id", sqlmodel.sql.sqltypes.AutoString(), nullable=False),
        sa.Column(
            "state",
            postgresql.ENUM(
                "PROCESSED", "ERROR", name="email_state_enum", create_type=False
            ),
            nullable=False,
        ),
        sa.Column("created_at", sa.DateTime(), nullable=False),
        sa.Column("id", sa.Uuid(), nullable=False),
        sa.Column("owner_id", sa.Uuid(), nullable=False),
        sa.ForeignKeyConstraint(["owner_id"], ["email.id"], ondelete="CASCADE"),
        sa.PrimaryKeyConstraint("id"),
    )
    op.create_index(
        op.f("ix_emaildata_created_at"), "emaildata", ["created_at"], unique=False
    )

    # 1. First add the email column as nullable
    op.add_column(
        "email", sa.Column("email", sqlmodel.sql.sqltypes.AutoString(), nullable=True)
    )

    # 2. Copy email_id values to email column for existing records
    connection.execute(text("UPDATE email SET email = email_id"))

    # 3. Now make the email column non-nullable
    op.alter_column("email", "email", nullable=False)

    # 4. Drop old columns
    op.drop_column("email", "state")
    op.drop_column("email", "email_id")
    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    # First get connection
    connection = op.get_bind()

    # Add back the columns we need
    op.add_column(
        "email",
        sa.Column("email_id", sa.VARCHAR(), autoincrement=False, nullable=True),
    )
    op.add_column(
        "email",
        sa.Column(
            "state",
            postgresql.ENUM("PROCESSED", "ERROR", name="email_state_enum"),
            autoincrement=False,
            nullable=True,
        ),
    )

    # Copy email values back to email_id
    connection.execute(text("UPDATE email SET email_id = email, state = 'PROCESSED'"))

    # Make columns non-nullable
    op.alter_column("email", "email_id", nullable=False)
    op.alter_column("email", "state", nullable=False)

    # Finally drop the new column
    op.drop_column("email", "email")
    op.drop_index(op.f("ix_emaildata_created_at"), table_name="emaildata")
    op.drop_table("emaildata")
    # ### end Alembic commands ###
